import moment from 'moment'

type payment = {
	student: MISStudent
	payment_id: string
} & MISStudentPayment

// i want this function wrapped in comlink

export function checkStudentDuesReturning(
	student: AugmentedStudent,
	settings?: MISSettings
): payment[] {
	const curr = moment().format('MM/YYYY')

	const payments: payment[] = []

	// todo: generate payment entry for class default fee
	// What will be payment id for class default fee? - curr + class_id
	// Do we have to guide school owners to remove fee monthly from student profile
	// or we can check if class default fee set, generate from it?

	// todo: generate payments entries for class additional fees

	// merge student fees and class fees
	let fees: Array<[string, MISStudentFee | MISClassFee]> = Object.entries(student.fees ?? {})

	// if (student.section?.class_id) {
	// 	// get default class fee
	// 	const classFee = settings?.classes?.defaultFee?.[student.section.class_id]

	// 	// get class additional fees
	// 	const classAdditionals = settings?.classes?.additionalFees?.[student.section.class_id]

	// 	if (classFee) {
	// 		// payment id will be generated by classs id
	// 		fees.push([student.section.class_id, classFee])
	// 	}

	// 	if (classAdditionals) {
	// 		const additionals = Object.entries(classAdditionals ?? {})
	// 		fees.push(...additionals)
	// 	}
	// }

	for (const [id, fee] of fees) {
		if (fee.period === 'MONTHLY' && student.Active) {
			// check if this fee exists in "owed" column.

			const existing_monthly = Object.values(student.payments ?? {}).find(p => {
				return p.fee_id === id && moment(p.date).format('MM/YYYY') === curr
			})
			if (existing_monthly === undefined) {
				// there is no payment for this month owed yet
				// create it

				payments.push({
					student,
					payment_id: `${curr}-${id}`,
					amount: parseFloat(fee.amount as string) ?? 0,
					date: moment().startOf('month').unix() * 1000,
					type: fee.type == 'FEE' ? 'OWED' : 'FORGIVEN',
					fee_id: id,
					fee_name: fee.name
				})
			}
		}

		if (fee.period === 'SINGLE') {
			const existing_one_time = Object.values(student.payments ?? {}).find(
				p => p.fee_id === id
			)
			if (existing_one_time === undefined) {
				payments.push({
					student,
					payment_id: id,
					amount: parseFloat(fee.amount as string) ?? 0,
					date: moment.now(),
					type: fee.type == 'FEE' ? 'OWED' : 'FORGIVEN',
					fee_id: id,
					fee_name: fee.name
				})
			}
		}
	}

	return payments
}
