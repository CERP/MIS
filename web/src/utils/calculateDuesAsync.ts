import moment from 'moment'

type payment = {
	student: AugmentedStudent
	payment_id: string
} & MISStudentPayment

export default function checkMultipleStudentsDuesReturning(
	students: AugmentedStudent[],
	settings?: RootDBState['settings']
): Promise<payment[]> {
	return new Promise((resolve, reject) => {
		let i = 0
		let payments: payment[] = []

		const checkNextStudent = () => {
			if (i >= students.length) {
				// we are done calculating dues
				return resolve(payments)
			}

			const dues = checkStudentDuesReturning(students[i], settings)
			i += 1

			payments = payments.concat(dues)

			setTimeout(checkNextStudent, 0)
		}

		setTimeout(checkNextStudent, 0)
	})
}

function checkStudentDuesReturning(
	student: AugmentedStudent,
	settings?: RootDBState['settings']
): payment[] {
	const curr = moment().format('MM/YYYY')

	const payments: payment[] = []

	// Date: 01-07-2021
	// We're going to halt generating payments of fee type 'FEE' and period 'MONTHLY' from student profile
	// because in future, payments would be generated from class fees of type 'MONTHLY'
	let fees: Array<[string, MISStudentFee | MISClassFee]> = Object.entries(
		student.fees ?? {}
	).filter(([id, fee]) => !(fee.type === 'FEE' && fee.period === 'MONTHLY'))

	if (student.section?.class_id) {
		// get default class fee
		const classFee = settings?.classes?.defaultFee?.[student.section.class_id]

		// get class additional fees
		const classAdditionals = settings?.classes?.additionalFees?.[student.section.class_id]

		if (classFee && classFee.amount > 0) {
			// payment id will be generated by student id
			// to keep track of monthly generated fee
			fees.push([student.id, classFee])
		}

		if (classAdditionals) {
			const additionals = Object.entries(classAdditionals ?? {})
			fees.push(...additionals)
		}
	}

	for (const [id, fee] of fees) {
		if (fee.period === 'MONTHLY' && student.Active) {
			// check if this fee exists in "owed" column.

			const existing_monthly = Object.values(student.payments ?? {}).find(p => {
				return p.fee_id === id && moment(p.date).format('MM/YYYY') === curr
			})
			if (existing_monthly === undefined) {
				// there is no payment for this month owed yet
				// create it
				const amount =
					(fee.type === 'FEE' ? 1 : -1) * parseFloat(fee.amount?.toString() ?? '0')

				payments.push({
					student,
					payment_id: `${curr}-${id}`,
					amount,
					date: moment().startOf('month').unix() * 1000,
					type: 'OWED',
					fee_id: id,
					fee_name: fee.name
				})
			}
		}

		if (fee.period === 'SINGLE' && student.Active) {
			const existing_one_time = Object.values(student.payments ?? {}).find(
				p => p.fee_id === id
			)
			if (existing_one_time === undefined) {
				const amount =
					(fee.type === 'FEE' ? 1 : -1) * parseFloat(fee.amount?.toString() ?? '0')

				payments.push({
					student,
					payment_id: id,
					amount,
					date: moment.now(),
					type: 'OWED',
					fee_id: id,
					fee_name: fee.name
				})
			}
		}
	}

	return payments
}
