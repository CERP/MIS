{"ast":null,"code":"import _regeneratorRuntime from \"/home/taimur/dev/cerp/mis/dashboard/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/home/taimur/dev/cerp/mis/dashboard/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/home/taimur/dev/cerp/mis/dashboard/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/taimur/dev/cerp/mis/dashboard/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { connected, disconnected } from '../actions/core';\nimport sleep from '../utils/sleep';\nimport { v4 } from 'uuid';\n\nvar Syncr =\n/*#__PURE__*/\nfunction () {\n  function Syncr(url, dispatch) {\n    _classCallCheck(this, Syncr);\n\n    this.url = void 0;\n    this.ready = void 0;\n    this.ws = void 0;\n    this.pingInterval = void 0;\n    this.dispatch = void 0;\n    this.pending = void 0;\n    this.message_timeout = void 0;\n    this.url = url;\n    this.ready = false;\n    this.ws = undefined;\n    this.pingInterval = undefined;\n    this.dispatch = dispatch;\n    this.message_timeout = 10000;\n    this.pending = new Map(); // key: uuid, value: promise\n\n    this.connect();\n  }\n\n  _createClass(Syncr, [{\n    key: \"connect\",\n    value: function () {\n      var _connect = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2() {\n        var _this = this;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                this.ws = new WebSocket(this.url);\n\n                this.ws.onopen = function () {\n                  _this.ready = true;\n                  clearInterval(_this.pingInterval);\n                  _this.pingInterval = window.setInterval(function () {\n                    return _this.ping();\n                  }, 5000);\n\n                  _this.dispatch(connected());\n                };\n\n                this.ws.onclose =\n                /*#__PURE__*/\n                function () {\n                  var _ref = _asyncToGenerator(\n                  /*#__PURE__*/\n                  _regeneratorRuntime.mark(function _callee(e) {\n                    return _regeneratorRuntime.wrap(function _callee$(_context) {\n                      while (1) {\n                        switch (_context.prev = _context.next) {\n                          case 0:\n                            if (_this.ready) {\n                              _this.pending.forEach(function (promise) {\n                                return promise.reject(\"disconnect\");\n                              });\n\n                              _this.dispatch(disconnected());\n                            }\n\n                            _this.cleanup();\n\n                            _context.next = 4;\n                            return sleep(9000 * Math.random() + 1000);\n\n                          case 4:\n                            _this.connect();\n\n                          case 5:\n                          case \"end\":\n                            return _context.stop();\n                        }\n                      }\n                    }, _callee);\n                  }));\n\n                  return function (_x) {\n                    return _ref.apply(this, arguments);\n                  };\n                }();\n\n                this.ws.onerror = function (err) {}; //console.error(\"websocket err\", err)\n\n\n                this.ws.onmessage = function (event) {\n                  var msg = JSON.parse(event.data);\n                  console.log(\"<--- server\", msg.type);\n\n                  if (msg.key) {\n                    var promise = _this.pending.get(msg.key);\n\n                    if (promise === undefined) {\n                      console.error(\"mesage not found in pending - will not process\");\n                      return;\n                    }\n\n                    if (msg.type === \"failure\") {\n                      promise.reject(msg.payload);\n                    } else {\n                      promise.resolve(msg.payload);\n                    }\n\n                    _this.pending.delete(msg.key);\n                  } else {\n                    _this.dispatch(msg);\n                  }\n                };\n\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function connect() {\n        return _connect.apply(this, arguments);\n      }\n\n      return connect;\n    }()\n  }, {\n    key: \"cleanup\",\n    value: function cleanup() {\n      this.ready = false;\n      clearInterval(this.pingInterval);\n      this.ws = undefined;\n    }\n  }, {\n    key: \"ping\",\n    value: function ping() {\n      if (this.ready) {\n        try {\n          this.ws && this.ws.send(\"ping\");\n        } catch (e) {\n          console.error(e);\n        }\n      }\n    }\n  }, {\n    key: \"send\",\n    value: function () {\n      var _send = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee3(message) {\n        var _this2 = this;\n\n        var key;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (this.ready) {\n                  _context3.next = 2;\n                  break;\n                }\n\n                throw new Error(\"not ready\");\n\n              case 2:\n                // make a key\n                // create promise, put in map\n                // when its returned, trigger it.\n                console.log(\"server --->\", message);\n                key = v4();\n                return _context3.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  _this2.pending.set(key, {\n                    resolve: resolve,\n                    reject: reject\n                  });\n\n                  if (!_this2.ws) {\n                    reject(\"ws is undefined\");\n                  } else {\n                    _this2.ws.send(JSON.stringify({\n                      key: key,\n                      payload: message\n                    }));\n                  }\n\n                  setTimeout(function () {\n                    var p = _this2.pending.get(key);\n\n                    if (p) {\n                      console.log(\"MSG TIMEOUT!!!\");\n                      p.reject(\"timeout\");\n                    }\n\n                    _this2.pending.delete(key);\n                  }, _this2.message_timeout);\n                }));\n\n              case 5:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function send(_x2) {\n        return _send.apply(this, arguments);\n      }\n\n      return send;\n    }()\n  }]);\n\n  return Syncr;\n}();\n\nexport { Syncr as default };","map":{"version":3,"sources":["/home/taimur/dev/cerp/mis/dashboard/src/syncr/index.ts"],"names":["connected","disconnected","sleep","v4","Syncr","url","dispatch","ready","ws","pingInterval","pending","message_timeout","undefined","Map","connect","WebSocket","onopen","clearInterval","window","setInterval","ping","onclose","e","forEach","promise","reject","cleanup","Math","random","onerror","err","onmessage","event","msg","JSON","parse","data","console","log","type","key","get","error","payload","resolve","delete","send","message","Error","Promise","set","stringify","setTimeout","p"],"mappings":"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","sourcesContent":["import { connected, disconnected } from '../actions/core'\nimport sleep from '../utils/sleep'\nimport { v4 } from 'uuid'\n\nexport default class Syncr {\n\n\turl: string;\n\tready: boolean;\n\tws?: WebSocket;\n\tpingInterval?: number;\n\tdispatch: (action: any) => void;\n\tpending: Map<string, { resolve: (a: any) => any, reject: (a :any) => any}>;\n\tmessage_timeout: number;\n\n\tconstructor(url : string, dispatch: (action: any) => void) {\n\n\t\tthis.url = url;\n\t\tthis.ready = false;\n\t\tthis.ws = undefined;\n\t\tthis.pingInterval = undefined;\n\t\tthis.dispatch = dispatch;\n\t\tthis.message_timeout = 10000;\n\n\t\tthis.pending = new Map(); // key: uuid, value: promise\n\n\t\tthis.connect();\n\t}\n\n\tasync connect() {\n\t\tthis.ws = new WebSocket(this.url);\n\n\t\tthis.ws.onopen = () => {\n\t\t\tthis.ready = true;\n\t\t\tclearInterval(this.pingInterval);\n\t\t\tthis.pingInterval = window.setInterval(() => this.ping(), 5000)\n\n\t\t\tthis.dispatch(connected())\n\t\t\t\n\t\t}\n\n\t\tthis.ws.onclose = async (e) => {\n\t\t\tif(this.ready) {\n\t\t\t\tthis.pending.forEach(promise => promise.reject(\"disconnect\"));\n\t\t\t\tthis.dispatch(disconnected())\n\n\t\t\t}\n\t\t\tthis.cleanup();\n\t\t\tawait sleep(9000 * Math.random() + 1000);\n\t\t\tthis.connect();\n\t\t}\n\n\t\tthis.ws.onerror = err => {} //console.error(\"websocket err\", err)\n\n\t\tthis.ws.onmessage = event => {\n\t\t\tconst msg = JSON.parse(event.data)\n\n\t\t\tconsole.log(\"<--- server\", msg.type)\n\n\t\t\tif(msg.key) {\n\n\t\t\t\tconst promise = this.pending.get(msg.key);\n\t\t\t\tif(promise === undefined) {\n\t\t\t\t\tconsole.error(\"mesage not found in pending - will not process\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tif(msg.type === \"failure\") {\n\t\t\t\t\tpromise.reject(msg.payload)\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpromise.resolve(msg.payload)\n\t\t\t\t}\n\t\t\t\tthis.pending.delete(msg.key);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.dispatch(msg);\n\t\t\t}\n\t\t}\n\t}\n\n\tcleanup() {\n\t\tthis.ready = false;\n\t\tclearInterval(this.pingInterval)\n\t\tthis.ws = undefined;\n\t}\n\n\tping() {\n\t\tif(this.ready){\n\t\t\ttry {\n\t\t\t\tthis.ws && this.ws.send(\"ping\")\n\t\t\t}\n\t\t\tcatch (e) {\n\t\t\t\tconsole.error(e);\n\t\t\t}\n\t\t}\n\t}\n\n\tasync send(message : any) {\n\t\tif(!this.ready) {\n\t\t\tthrow new Error(\"not ready\");\n\t\t}\n\n\t\t// make a key\n\t\t// create promise, put in map\n\t\t// when its returned, trigger it.\n\t\tconsole.log(\"server --->\", message)\n\t\tconst key = v4();\n\t\treturn new Promise<any>((resolve, reject) => {\n\n\t\t\tthis.pending.set(key, {resolve, reject});\n\n\t\t\tif(!this.ws) {\n\t\t\t\treject(\"ws is undefined\")\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.ws.send(JSON.stringify({\n\t\t\t\t\tkey,\n\t\t\t\t\tpayload: message\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\tsetTimeout(() => {\n\t\t\t\tconst p = this.pending.get(key)\n\t\t\t\tif(p) {\n\t\t\t\t\tconsole.log(\"MSG TIMEOUT!!!\")\n\t\t\t\t\tp.reject(\"timeout\")\n\t\t\t\t}\n\t\t\t\tthis.pending.delete(key);\n\t\t\t}, this.message_timeout)\n\t\t});\n\n\t}\n\n}"]},"metadata":{},"sourceType":"module"}