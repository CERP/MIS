{"ast":null,"code":"import _defineProperty from \"/home/taimur/dev/cerp/mis/dashboard/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _objectSpread from \"/home/taimur/dev/cerp/mis/dashboard/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nvar SYNC = \"SYNC\"; // TODO: separate out connect, auth merges and deletes into separate folder\n\nexport var MERGES = \"MERGES\";\nexport var createMerges = function createMerges(merges) {\n  return function (dispatch, getState, syncr) {\n    // merges is a list of path, value\n    var action = {\n      type: MERGES,\n      merges: merges\n    };\n    dispatch(action);\n    var new_merges = merges.reduce(function (agg, curr) {\n      return _objectSpread({}, agg, _defineProperty({}, curr.path.join(','), {\n        action: {\n          type: \"MERGE\",\n          path: curr.path.map(function (p) {\n            return p === undefined ? \"\" : p;\n          }),\n          value: curr.value\n        },\n        date: new Date().getTime()\n      }));\n    }, {});\n    var state = getState();\n\n    var rationalized_merges = _objectSpread({}, state.queued, new_merges);\n\n    var payload = {\n      type: SYNC,\n      id: state.auth.id,\n      client_type: state.auth.client_type,\n      last_snapshot: state.last_snapshot,\n      payload: rationalized_merges\n    };\n    syncr.send(payload).then(dispatch).catch(function (err) {\n      return dispatch(QueueUp(new_merges));\n    });\n  };\n};\nexport var SMS = \"SMS\";\nexport var sendSMS = function sendSMS(text, number) {\n  return function (dispatch, getState, syncr) {\n    // should i keep a log of all messages sent in the db?\n    var state = getState();\n    syncr.send({\n      type: SMS,\n      client_type: state.auth.client_type,\n      id: state.auth.id,\n      payload: {\n        text: text,\n        number: number\n      }\n    }).then(dispatch).catch(function (err) {\n      return console.error(err);\n    }); // this should backup to sending the sms via the android app?\n  };\n};\nexport var BATCH_SMS = \"BATCH_SMS\";\nexport var sendBatchSMS = function sendBatchSMS(messages) {\n  return function (dispatch, getState, syncr) {\n    var state = getState();\n    syncr.send({\n      type: BATCH_SMS,\n      client_type: state.auth.client_type,\n      id: state.auth.id,\n      payload: {\n        messages: messages\n      }\n    }).catch(function (err) {\n      console.error(err); // send via android app?\n    });\n  };\n};\nexport var sendServerAction = function sendServerAction(action) {\n  return function (dispatch, getState, syncr) {\n    var state = getState();\n    console.log('send server action...', action);\n    return syncr.send({\n      type: action.type,\n      client_type: state.auth.client_type,\n      client_id: state.client_id,\n      id: state.auth.id,\n      payload: action.payload\n    }).then(dispatch).catch(function (err) {\n      console.error(err);\n    }); // should it get queued up....\n  };\n};\nexport var DELETES = \"DELETES\";\nexport var createDeletes = function createDeletes(paths) {\n  return function (dispatch, getState, syncr) {\n    var action = {\n      type: DELETES,\n      paths: paths\n    };\n    dispatch(action);\n    var state = getState();\n    var payload = paths.reduce(function (agg, curr) {\n      return _objectSpread({}, agg, _defineProperty({}, curr.path.join(','), {\n        action: {\n          type: \"DELETE\",\n          path: curr.path.map(function (x) {\n            return x === undefined ? \"\" : x;\n          }),\n          value: 1\n        },\n        date: new Date().getTime()\n      }));\n    }, {});\n\n    var rationalized_deletes = _objectSpread({}, state.queued, payload);\n\n    syncr.send({\n      type: SYNC,\n      client_type: state.auth.client_type,\n      school_id: state.auth.id,\n      last_snapshot: state.last_snapshot,\n      payload: rationalized_deletes\n    }).then(dispatch).catch(function (err) {\n      return dispatch(QueueUp(payload));\n    });\n  };\n}; // this is only produced by the server. \n// it will tell us it hsa confirmed sync up to { date: timestamp }\n\nexport var CONFIRM_SYNC = \"CONFIRM_SYNC\";\nexport var CONFIRM_SYNC_DIFF = \"CONFIRM_SYNC_DIFF\";\nexport var SNAPSHOT = \"SNAPSHOT\";\nexport var SNAPSHOT_DIFF = \"SNAPSHOT_DIFF\";\nexport var QUEUE = \"QUEUE\"; // queue up an object where key is path, value is action/date\n\nexport var QueueUp = function QueueUp(action) {\n  return {\n    type: QUEUE,\n    payload: action\n  };\n};\nexport var ON_CONNECT = \"ON_CONNECT\";\nexport var ON_DISCONNECT = \"ON_DISCONNECT\";\nexport var connected = function connected() {\n  return function (dispatch, getState, syncr) {\n    var action = {\n      type: ON_CONNECT\n    };\n    dispatch(action);\n    var state = getState();\n\n    if (state.auth.id && state.auth.token) {\n      syncr.send({\n        type: \"VERIFY\",\n        client_type: state.auth.client_type,\n        payload: {\n          id: state.auth.id,\n          token: state.auth.token,\n          client_id: state.client_id\n        }\n      }).then(function (res) {\n        return syncr.send({\n          type: SYNC,\n          client_type: state.auth.client_type,\n          id: state.auth.id,\n          payload: state.queued,\n          last_snapshot: state.last_snapshot\n        });\n      }).then(function (resp) {\n        dispatch(resp);\n      }).catch(function (err) {\n        console.error(err);\n        alert(\"Authorization Failed. Log out and Log in again.\");\n      });\n    }\n  };\n};\nexport var disconnected = function disconnected() {\n  return {\n    type: ON_DISCONNECT\n  };\n};\nexport var LOGIN_FAIL = \"LOGIN_FAIL\";\nexport var createLoginFail = function createLoginFail() {\n  return {\n    type: LOGIN_FAIL\n  };\n};\nexport var LOGIN_SUCCEED = \"LOGIN_SUCCEED\";\nexport var createLoginSucceed = function createLoginSucceed(id, token, sync_state) {\n  return {\n    type: LOGIN_SUCCEED,\n    id: id,\n    token: token,\n    sync_state: sync_state\n  };\n};","map":{"version":3,"sources":["/home/taimur/dev/cerp/mis/dashboard/src/actions/core.ts"],"names":["SYNC","MERGES","createMerges","merges","dispatch","getState","syncr","action","type","new_merges","reduce","agg","curr","path","join","map","p","undefined","value","date","Date","getTime","state","rationalized_merges","queued","payload","id","auth","client_type","last_snapshot","send","then","catch","err","QueueUp","SMS","sendSMS","text","number","console","error","BATCH_SMS","sendBatchSMS","messages","sendServerAction","log","client_id","DELETES","createDeletes","paths","x","rationalized_deletes","school_id","CONFIRM_SYNC","CONFIRM_SYNC_DIFF","SNAPSHOT","SNAPSHOT_DIFF","QUEUE","ON_CONNECT","ON_DISCONNECT","connected","token","res","resp","alert","disconnected","LOGIN_FAIL","createLoginFail","LOGIN_SUCCEED","createLoginSucceed","sync_state"],"mappings":"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","sourcesContent":["import { Dispatch, AnyAction } from 'redux'\nimport Syncr from '../syncr';\n\nconst SYNC = \"SYNC\"\n\n// TODO: separate out connect, auth merges and deletes into separate folder\nexport const MERGES = \"MERGES\"\n\ninterface Merge {\n\tpath: string[],\n\tvalue: any\n}\n\nexport interface MergeAction {\n\ttype: \"MERGES\",\n\tmerges: Merge[]\n}\n\nexport const createMerges= (merges : Merge[]) => (dispatch : (a: any) => any, getState: () => RootReducerState, syncr: Syncr) => {\n\t// merges is a list of path, value\n\n\tconst action = {\n\t\ttype: MERGES,\n\t\tmerges\n\t}\n\n\tdispatch(action)\n\n\tconst new_merges = merges.reduce((agg, curr) => ({\n\t\t...agg,\n\t\t[curr.path.join(',')]: {\n\t\t\taction: {\n\t\t\t\ttype: \"MERGE\",\n\t\t\t\tpath: curr.path.map(p => p === undefined ? \"\" : p),\n\t\t\t\tvalue: curr.value\n\t\t\t},\n\t\t\tdate: new Date().getTime()\n\t\t}\n\t}), {})\n\n\tconst state = getState();\n\tconst rationalized_merges = {...state.queued, ...new_merges}\n\n\tconst payload = {\n\t\ttype: SYNC,\n\t\tid: state.auth.id,\n\t\tclient_type: state.auth.client_type,\n\t\tlast_snapshot: state.last_snapshot,\n\t\tpayload: rationalized_merges\n\t}\n\n\tsyncr.send(payload)\n\t\t.then(dispatch)\n\t\t.catch(err => dispatch(QueueUp(new_merges)))\n}\n\nexport const SMS = \"SMS\"\nexport const sendSMS = (text : string, number : string) => (dispatch : (a: any) => any, getState: () => RootReducerState, syncr: Syncr) => {\n\n\t// should i keep a log of all messages sent in the db?\n\n\tconst state = getState();\n\tsyncr.send({\n\t\ttype: SMS,\n\t\tclient_type: state.auth.client_type,\n\t\tid: state.auth.id,\n\t\tpayload: {\n\t\t\ttext,\n\t\t\tnumber,\n\t\t}\n\t})\n\t.then(dispatch)\n\t.catch((err : Error) => console.error(err)) // this should backup to sending the sms via the android app?\n}\n\n\nexport const BATCH_SMS = \"BATCH_SMS\"\ninterface SMS {\n\ttext: string,\n\tnumber: string\n}\n\nexport const sendBatchSMS = (messages: SMS[]) => (dispatch: (a: any) => any, getState: () => RootReducerState, syncr: Syncr) => {\n\n\tconst state = getState();\n\tsyncr.send({\n\t\ttype: BATCH_SMS,\n\t\tclient_type: state.auth.client_type,\n\t\tid: state.auth.id,\n\t\tpayload: {\n\t\t\tmessages\n\t\t}\n\t})\n\t.catch((err: Error) => {\n\t\tconsole.error(err) // send via android app?\n\t})\n}\n\ninterface ServerAction {\n\ttype: string,\n\tpayload: any\n}\n\nexport const sendServerAction = ( action: ServerAction ) => (dispatch: Dispatch, getState: () => RootReducerState, syncr: Syncr) => {\n\tconst state = getState();\n\n\tconsole.log('send server action...', action)\n\treturn syncr.send({\n\t\ttype: action.type,\n\t\tclient_type: state.auth.client_type,\n\t\tclient_id: state.client_id,\n\t\tid: state.auth.id,\n\t\tpayload: action.payload\n\t})\n\t.then(dispatch)\n\t.catch((err : Error) => {\n\t\tconsole.error(err)\n\t})\n\n\t// should it get queued up....\n}\n\nexport const DELETES = \"DELETES\"\ninterface Delete {\n\tpath: string[]\n}\n\nexport interface DeletesAction {\n\ttype: \"DELETES\",\n\tpaths: Delete[]\n}\n\nexport const createDeletes = (paths : Delete[]) => (dispatch : Dispatch<AnyAction>, getState : () => RootReducerState, syncr : Syncr) => {\n\n\tconst action = {\n\t\ttype: DELETES,\n\t\tpaths\n\t}\n\n\tdispatch(action)\n\n\tconst state = getState();\n\tconst payload = paths.reduce((agg, curr) => ({\n\t\t\t...agg, \n\t\t\t[curr.path.join(',')]: {\n\t\t\t\taction: {\n\t\t\t\t\ttype: \"DELETE\",\n\t\t\t\t\tpath: curr.path.map(x => x === undefined ? \"\" : x),\n\t\t\t\t\tvalue: 1\n\t\t\t\t},\n\t\t\t\tdate: new Date().getTime()\n\t\t\t}\n\t\t}), {})\n\t\n\tconst rationalized_deletes = {...state.queued, ...payload}\n\n\tsyncr.send({\n\t\ttype: SYNC,\n\t\tclient_type: state.auth.client_type,\n\t\tschool_id: state.auth.id,\n\t\tlast_snapshot: state.last_snapshot,\n\t\tpayload: rationalized_deletes\n\t})\n\t.then(dispatch)\n\t.catch((err : Error) => dispatch(QueueUp(payload)))\n\n}\n\n// this is only produced by the server. \n// it will tell us it hsa confirmed sync up to { date: timestamp }\nexport const CONFIRM_SYNC = \"CONFIRM_SYNC\"\nexport const CONFIRM_SYNC_DIFF = \"CONFIRM_SYNC_DIFF\"\nexport interface ConfirmSyncAction {\n\ttype: \"CONFIRM_SYNC_DIFF\",\n\tdate: number,\n\tnew_writes: Write[]\n}\n\nexport interface Write {\n\tdate: number,\n\tvalue: any,\n\tpath: string[],\n\ttype: \"MERGE\" | \"DELETE\",\n\tclient_id: string\n}\n\nexport const SNAPSHOT = \"SNAPSHOT\"\nexport const SNAPSHOT_DIFF = \"SNAPSHOT_DIFF\"\n\nexport interface SnapshotDiffAction {\n\tnew_writes: {\n\t\t[path_string: string]: {\n\t\t\ttype: \"MERGE\" | \"DELETE\",\n\t\t\tpath: string[],\n\t\t\tvalue?: any\n\t\t}\n\t}\n}\n\nexport const QUEUE = \"QUEUE\"\n// queue up an object where key is path, value is action/date\ninterface Queuable {\n\t[path: string] : {\n\t\taction: {\n\t\t\ttype: \"MERGE\" | \"DELETE\",\n\t\t\tpath: string[],\n\t\t\tvalue?: any\n\t\t},\n\t\tdate: number\n\t}\n}\n\nexport interface QueueAction {\n\ttype: \"QUEUE\",\n\tpayload: Queuable\n}\n\nexport const QueueUp = (action : Queuable) => {\n\treturn {\n\t\ttype: QUEUE,\n\t\tpayload: action\n\t}\n}\n\nexport const ON_CONNECT = \"ON_CONNECT\"\nexport const ON_DISCONNECT = \"ON_DISCONNECT\"\nexport const connected = () => (dispatch: (a : any) => any, getState: () => RootReducerState, syncr: Syncr) => { \n\tconst action = {type: ON_CONNECT}\n\n\tdispatch(action)\n\n\tconst state = getState();\n\n\tif(state.auth.id && state.auth.token) {\n\t\tsyncr\n\t\t\t.send({\n\t\t\t\ttype: \"VERIFY\",\n\t\t\t\tclient_type: state.auth.client_type,\n\t\t\t\tpayload: {\n\t\t\t\t\tid: state.auth.id,\n\t\t\t\t\ttoken: state.auth.token,\n\t\t\t\t\tclient_id: state.client_id,\n\t\t\t\t}\n\t\t\t})\n\t\t\t.then(res => {\n\t\t\t\treturn syncr.send({\n\t\t\t\t\ttype: SYNC,\n\t\t\t\t\tclient_type: state.auth.client_type,\n\t\t\t\t\tid: state.auth.id,\n\t\t\t\t\tpayload: state.queued,\n\t\t\t\t\tlast_snapshot: state.last_snapshot\n\t\t\t\t})\n\t\t\t})\n\t\t\t.then(resp => {\n\t\t\t\tdispatch(resp)\n\t\t\t})\n\t\t\t.catch(err => {\n\t\t\t\tconsole.error(err)\n\t\t\t\talert(\"Authorization Failed. Log out and Log in again.\")\n\t\t\t})\n\t}\n}\n\nexport const disconnected = () => ({ type: ON_DISCONNECT })\n\nexport const LOGIN_FAIL = \"LOGIN_FAIL\"\nexport const createLoginFail = () => ({ type: LOGIN_FAIL })\n\nexport const LOGIN_SUCCEED = \"LOGIN_SUCCEED\"\nexport interface LoginSucceed {\n\ttype: \"LOGIN_SUCCEED\",\n\tid: string,\n\ttoken: string,\n\tsync_state: RootReducerState['sync_state'],\n}\n\nexport const createLoginSucceed = (id : string, token : string, sync_state: RootReducerState['sync_state']) : LoginSucceed => ({ \n\ttype: LOGIN_SUCCEED,\n\tid,\n\ttoken,\n\tsync_state\n})\n"]},"metadata":{},"sourceType":"module"}